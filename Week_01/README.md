学习笔记

自顶向下的变成方法。
自己在开发过程中有过无意识的用到过这种方法。每次都效率很高，很少bug。但前提是自己对于实现方案了然于胸，还没写已经开到了全貌。我需要在将来的编程中刻意的使用这种方法。

记忆两重遍历的写法。
几乎每次写两重遍历，脑子都要计算一遍下标i与j该如何设置才能避免重复。虽然最终都能给出正确答案，但是浪费了时间和脑力。所以只有两句话，但是需要背下来。
for( int i = 0; i < nums.length - 1; ++i )
    for ( int j = i+1; j < nums.length; ++j )
要点1：i的边界条件是 i < nums.length - 1, 不是i < nums.length。
要点2：第二层j的初始条件是int j = i
道理很简单，但背下来提高未来开发效率和准确性。


关于盛最多水容器的最优解法。这题我之前做过并且给出了最优方案，但是当时在想出这个方案前一直想证明双指针缩进的正确性。
https://leetcode-cn.com/problems/container-with-most-water/solution/shuang-zhi-zhen-fa-zheng-que-xing-zheng-ming-by-r3/
给出了证明，让我了解到当在怀疑双指针解法是否合法时需要借助数学证明让自己对于双指针缩进解法有底气。我对于双指针缩进解法的评论是：技法很容易想到，但贵在需要证明被略过的搜索空间是无效解集。

另外，提炼一下当使用双指针缩进法的时候应该使用的最优循环写法。
for ( int i = 0, j = nums.length - 1; i < j; )
同样背下来！

另外提一句我是支持背诵代码的，因为这就像是人类学习语言，我在学校学习英语的时候都是先学语法，语法学的滚瓜烂熟。但是在实际使用过程中就是哑巴英语。最可笑的是，native speaker都不懂语法。人类在使用语言的时候，大脑其实在搜索使用已经被记忆的句式，甚至段落。然后使用复杂度较低的替换算法将当前场景的词语像做填空题一样填入，然后说出来。这是典型的空间换时间的解法。脑容量不是问题，但脑力是问题。同样学习编程也有相同的情况，要想速度快脑子必须要避免重新造轮子。


爬楼梯的问题
我之前做题的时候是在观察了1，2，3，4阶楼梯的结果后发现是斐波那契数列。题解没有太多解释，只要记住不要用递归，用循环保留三个数即可。那么我在这题中想要总结的是怎样的题型或者说场景会需要用斐波那契数列来套模型？我还没有总结出一个通项规律，当前看到的几个用例包括，兔子繁殖问题，投掷硬币问题，爬楼梯问题，这三个问题中都有数字2。不继续考虑下去了，暂时留个心眼。
所以这套题目可以提炼的信息除了最优的斐波那契的写法，还有就是可以在拿到题目后通过计算1-3/4的情况来发现其中的规律。然后看看能否用已知的数学原理来解。题外，斐波那契有O（1）的通项公式来求解。


3数之和问题
这个问题是盛最多水问题的升级版本，并且提高了难度。如果选用暴力破解，需要注意三重循环的边界值设定，确保精确避免重复case。双指针思想和盛最多水的情况是一至的。

循环链表的解法很有趣。我原本担心快慢指针会不会在某些情况下会让快指针套圈几次才能与慢指针相遇？其实不会。
证明：设慢指针的位置是n，快指针在与慢指针不重叠的前提下的位置有如下情况。
n-2k k >= 1
n-(2k-1) k >= 1
去除2k这个周期性快指针最接近慢指针，但又没有超过慢指针的情况便是当k=1时，即n-2, n-1。
然后此时继续走一步，慢指针的位置是n+1
快指针走一步是n-2+2=n,n-1+2=n+1
第二种情况重叠发生。第一种情况其实变成了之前n-1的样子。如果再走一步的话便能重叠。所以不会出现需要快指针套圈几次后才能重叠的情况。一定会在快指针最接近慢指针的2步之内与慢指针重叠。
接着问题来了为什么快指针每次只多跑一步呢？可以2步吗？同样讨论如下
设慢指针位置为n
快指针位置可能是
n-3k
n-3k-1
n-3k-2
去除周期性
n-3
n-2
n-1
走一步，慢指针位置：n+1
快指针位置分别为
n-3+3=n
n-2+3=n+1
n-1+3=n+2
发现没问题来了，在第三种情况下快指针超过了慢指针，这就意味着快指针势必要起码多套一圈才有可能相遇。是否会再再要多套一圈，这取决于一圈中节点的数量。所以无法用多走两步的形式。必须使用慢指针1步，快指针2步的方式.
总的而言，如果某些使用场景可以抽象为一个带环链表，又需要调查是否有环的情况下。这种算法是有效的。
